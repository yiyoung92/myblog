'use strict';

const node_path = require('node:path');
const node_process = require('node:process');
const colorette = require('colorette');
const _debug = require('debug');
const tinyglobby = require('tinyglobby');
const Token = require('markdown-it/lib/token.mjs');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const _debug__default = /*#__PURE__*/_interopDefaultCompat(_debug);
const Token__default = /*#__PURE__*/_interopDefaultCompat(Token);

const name = "@nolebase/markdown-it-bi-directional-links";
const packageJSON = {
	name: name};

const caseInsensitiveCompare = new Intl.Collator(void 0, { sensitivity: "accent" }).compare;
function findBiDirectionalLinks(possibleBiDirectionalLinksInFilePaths, possibleBiDirectionalLinksInFullFilePaths, href) {
  if (!href)
    return null;
  if (href.includes(node_path.sep))
    return possibleBiDirectionalLinksInFullFilePaths[href] ?? Object.entries(possibleBiDirectionalLinksInFullFilePaths).filter((p) => caseInsensitiveCompare(href, p[0]) === 0).map((p) => p[1]);
  return possibleBiDirectionalLinksInFilePaths[href] ?? Object.entries(possibleBiDirectionalLinksInFilePaths).filter((p) => caseInsensitiveCompare(href, p[0]) === 0).map((p) => p[1]);
}
function genLink(state, resolvedNewHref, text, md, href, link, isInvalid = false) {
  if (isInvalid) {
    const openToken2 = state.push("link_open", "a", 1);
    openToken2.attrSet("class", "route-link nolebase-route-link-invalid");
    openToken2.attrSet("href", "#");
    openToken2.attrSet("target", "_target");
    const pushedToken = state.push("text", "", 0);
    pushedToken.content = text;
    state.push("link_close", "a", -1);
    state.pos += link[0].length;
    return;
  }
  const openToken = state.push("link_open", "a", 1);
  openToken.attrSet("href", resolvedNewHref);
  const linkTokenChildrenContent = [];
  const parsedUrl = new URL(href, "https://a.com");
  const hrefWithoutSearchAndHash = decodeURIComponent(parsedUrl.pathname.slice(1));
  const parsedInlineTokens = text ? md.parseInline(text, state.env) : md.parseInline(hrefWithoutSearchAndHash, state.env) || [];
  if (parsedInlineTokens && parsedInlineTokens.length) {
    parsedInlineTokens.forEach((tokens) => {
      if (!tokens.children)
        return;
      tokens.children.forEach((token) => {
        linkTokenChildrenContent.push(token);
      });
    });
  }
  for (const token of linkTokenChildrenContent) {
    const pushedToken = state.push(token.type, token.tag, token.nesting);
    pushedToken.content = token.content;
  }
  state.push("link_close", "a", -1);
  state.pos += link[0].length;
}
function genImage(state, resolvedNewHref, text, link) {
  const openToken = state.push("image", "img", 1);
  openToken.attrSet("src", resolvedNewHref);
  openToken.attrSet("alt", "");
  openToken.children = [];
  openToken.content = text;
  const innerTextToken = new Token__default("text", "", 0);
  innerTextToken.content = text;
  openToken.children.push(innerTextToken);
  state.pos += link[0].length;
}
function genVideo(state, resolvedNewHref, text, link) {
  const openToken = state.push("video_open", "video", 1);
  openToken.attrSet("controls", "true");
  openToken.attrSet("preload", "metadata");
  if (text)
    openToken.attrSet("aria-label", text);
  const sourceOpenToken = state.push("source_open", "source", 1);
  sourceOpenToken.attrSet("src", resolvedNewHref);
  state.push("video_close", "video", -1);
  state.pos += link[0].length;
}
function genAudio(state, resolvedNewHref, text, link) {
  const openToken = state.push("audio_open", "audio", 1);
  openToken.attrSet("controls", "true");
  openToken.attrSet("preload", "metadata");
  if (text)
    openToken.attrSet("aria-label", text);
  const sourceOpenToken = state.push("source_open", "source", 1);
  sourceOpenToken.attrSet("src", resolvedNewHref);
  state.push("audio_close", "audio", -1);
  state.pos += link[0].length;
}

const biDirectionalLinkPattern = /!?\[\[([^|\]\n]+)(\|([^\]\n]+))?\]\](?!\()/;
const biDirectionalLinkPatternWithStart = /^!?\[\[[^|\]\n]+(\|[^\]\n]+)?\]\](?!\()/;
const IMAGES_EXTENSIONS = [
  ".png",
  ".jpg",
  ".jpeg",
  ".gif",
  ".svg",
  ".webp",
  ".ico",
  ".bmp",
  ".tiff",
  ".apng",
  ".avif",
  ".jfif",
  ".pjpeg",
  ".pjp",
  ".svg",
  ".webp",
  ".xbm"
];
const AUDIO_EXTENSIONS = [
  ".mp3",
  ".flac",
  ".wav",
  ".ogg",
  ".opus",
  ".webm",
  ".acc"
];
const VIDEOS_EXTENSIONS = [
  ".mp4",
  ".webm",
  ".mov",
  ".mkv",
  ".ogg",
  ".3gp",
  ".flv"
];
const debug = _debug__default(packageJSON.name);
const logModulePrefix = `${colorette.cyan(packageJSON.name)}${colorette.gray(":")}`;
function warn(debugOn, format, ...params) {
  if (debugOn)
    console.warn(`${logModulePrefix} ${colorette.yellow("[WARN]")} ${format}`, ...params);
  else
    debug(`${logModulePrefix} ${colorette.yellow("[WARN]")} ${format}`, ...params);
}
function logFailedToMatchMarkupWarning(input, debugOn) {
  warn(debugOn, `Failed to match markup '${input}'.`);
}
function logIncorrectMatchedMarkupWarning(input, src, path, debugOn) {
  warn(debugOn, `Matched markup '${input}' is not at the start of the text. ${colorette.yellow(`

Things to check:

  1. Is this a expected markup for bi-directional links?
  2. Is there any other markup before this markup?`)}

${colorette.yellow("Source text:")}

  ${colorette.gray(src)}

  ${colorette.gray(`at`)} ${colorette.cyan(path)}
`);
}
function logNoMatchedFileWarning(rootDir, inputContent, markupTextContent, href, osSpecificHref, path, debugOn, relevantPath) {
  warn(debugOn, `No matched file found for '${osSpecificHref}' based on ${rootDir}, ignored. ${colorette.yellow(`

Things to check:

  1. Was the matched most relevant file expected?
    1. Was it renamed during the build process?
    2. Does it exist in the file system with the correct path?
    3. Does it have the correct extension? (Either .md for Markdown files or image extensions)
    4. Does it have any special characters in the file name? (e.g. back slashes, quotes, illegal characters, etc.)
  2. If <N/A> was shown, it means no relevant path was found. In such cases:
    1. Check the file system for the file if you expect it to get matched.
    2. Check whether mis-spelling or incorrect path was used in the markup.
  3. If you are using a custom base directory, check whether the base directory is correct.`)}

Matching chain:

  ${colorette.gray(inputContent)}
    -> ${colorette.gray(markupTextContent)}
      -> ${colorette.gray(href)}

${relevantPath ? `The most relevant path: "${colorette.gray(relevantPath.key ?? "<N/A>")}" matched by ${relevantPath.source ?? "<N/A>"}` : ""}

  ${colorette.gray("at")} "${colorette.cyan(path)}"
`);
}
function logMultipleCaseInsensitiveMatchedFilesWarning(rootDir, debugOn, osSpecificHref, hrefs) {
  warn(debugOn, `Multiple case-insensitive matched files found for '${osSpecificHref}' based on ${rootDir}, using the first one.

All matched files:

 - ${colorette.gray(hrefs.join("\n - "))}
`);
}
function findTheMostRelevantOne(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, href) {
  for (const key in possibleBiDirectionalLinksInCleanBaseNameOfFilePaths) {
    if (key.includes(href)) {
      return {
        key: possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[key],
        source: "file name"
      };
    }
  }
  for (const key in possibleBiDirectionalLinksInFullFilePaths) {
    if (key.includes(href)) {
      return {
        key: possibleBiDirectionalLinksInFullFilePaths[key],
        source: "absolute path"
      };
    }
  }
}
const BiDirectionalLinks = (options) => {
  const rootDir = options?.dir ?? node_process.cwd();
  const baseDir = options?.baseDir ?? "/";
  const includes = options?.includesPatterns ?? [];
  const excludes = options?.excludesPatterns ?? ["_*", "dist", "node_modules"];
  const debugOn = options?.debug ?? false;
  const noNoMatchedFileWarning = options?.noNoMatchedFileWarning ?? false;
  const stillRenderNoMatched = options?.stillRenderNoMatched ?? false;
  const isRelativePath = options?.isRelativePath ?? false;
  const possibleBiDirectionalLinksInCleanBaseNameOfFilePaths = {};
  const possibleBiDirectionalLinksInFullFilePaths = {};
  if (includes.length === 0) {
    includes.push("**/*.md");
    IMAGES_EXTENSIONS.forEach((ext) => includes.push(`**/*${ext}`));
    AUDIO_EXTENSIONS.forEach((ext) => includes.push(`**/*${ext}`));
    VIDEOS_EXTENSIONS.forEach((ext) => includes.push(`**/*${ext}`));
  }
  const files = tinyglobby.globSync(includes, {
    onlyFiles: true,
    absolute: true,
    cwd: rootDir,
    ignore: excludes
  });
  for (const file of files) {
    const relativeFilePath = node_path.relative(rootDir, file);
    const partialFilePathWithOnlyBaseName = node_path.basename(relativeFilePath);
    const existingFileName = possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName];
    if (typeof existingFileName === "string" && existingFileName !== "") {
      delete possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName];
      delete possibleBiDirectionalLinksInFullFilePaths[existingFileName];
      possibleBiDirectionalLinksInFullFilePaths[relativeFilePath] = relativeFilePath;
      possibleBiDirectionalLinksInFullFilePaths[existingFileName] = existingFileName;
      continue;
    }
    possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName] = relativeFilePath;
    possibleBiDirectionalLinksInFullFilePaths[relativeFilePath] = relativeFilePath;
  }
  return (md) => {
    md.inline.ruler.after("text", "bi_directional_link_replace", (state) => {
      const src = state.src.slice(state.pos, state.posMax);
      const link = src.match(biDirectionalLinkPattern);
      if (!link) {
        logFailedToMatchMarkupWarning(src, debugOn);
        return false;
      }
      if (!link.input) {
        logFailedToMatchMarkupWarning(src, debugOn);
        return false;
      }
      if (!biDirectionalLinkPatternWithStart.exec(link.input)) {
        logIncorrectMatchedMarkupWarning(link.input, src, state.env.path, debugOn);
        return false;
      }
      const inputContent = link.input;
      const markupTextContent = link[0];
      const href = link[1].trim();
      const text = link[3]?.trim() ?? "";
      const isImageRef = IMAGES_EXTENSIONS.some((ext) => href.endsWith(ext));
      const isVideoRef = VIDEOS_EXTENSIONS.some((ext) => href.endsWith(ext));
      const isAudioRef = AUDIO_EXTENSIONS.some((ext) => href.endsWith(ext));
      const parsedHref = new URL(href.startsWith("?") ? node_path.relative(rootDir, state.env.path) + href : href, "https://a.com");
      const parsedPathname = decodeURIComponent(parsedHref.pathname.slice(1));
      const isToSelf = href.startsWith("#") || href.startsWith("^");
      if (isToSelf) {
        let resolvedNewHref2 = "";
        parsedHref.hash = href;
        resolvedNewHref2 = resolvedNewHref2 + parsedHref.search + parsedHref.hash;
        genLink(state, resolvedNewHref2, href.slice(1), md, href, link);
        return true;
      }
      let osSpecificHref = parsedPathname.split("/").join(node_path.sep);
      if (!isImageRef && !isAudioRef && !isVideoRef && (node_path.extname(osSpecificHref) === "" || node_path.extname(osSpecificHref) !== ".md"))
        osSpecificHref += ".md";
      const matchedHrefSingleOrArray = findBiDirectionalLinks(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, osSpecificHref);
      if (matchedHrefSingleOrArray === null || Array.isArray(matchedHrefSingleOrArray) && matchedHrefSingleOrArray.length === 0) {
        const relevantPath = findTheMostRelevantOne(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, osSpecificHref);
        logNoMatchedFileWarning(rootDir, inputContent, markupTextContent, href, osSpecificHref, state.env.path, !noNoMatchedFileWarning, relevantPath);
        if (stillRenderNoMatched) {
          genLink(state, "", href, md, href, link, true);
          return true;
        }
        return false;
      }
      let matchedHref;
      if (Array.isArray(matchedHrefSingleOrArray)) {
        matchedHref = matchedHrefSingleOrArray[0];
        if (matchedHrefSingleOrArray.length > 1)
          logMultipleCaseInsensitiveMatchedFilesWarning(rootDir, debugOn, osSpecificHref, matchedHrefSingleOrArray);
      } else {
        matchedHref = matchedHrefSingleOrArray;
      }
      let resolvedNewHref;
      if (isRelativePath) {
        if (state.env.relativePath) {
          resolvedNewHref = node_path.relative(node_path.dirname(state.env.relativePath), matchedHref).split(node_path.sep).join("/");
        } else if (state.env.filePathRelative) {
          resolvedNewHref = node_path.relative(node_path.dirname(state.env.filePathRelative), matchedHref).split(node_path.sep).join("/");
        } else {
          console.error("Can't find local file path");
          return false;
        }
      } else {
        resolvedNewHref = node_path.posix.join(
          baseDir,
          node_path.relative(rootDir, matchedHref).split(node_path.sep).join("/")
        );
      }
      if (isImageRef) {
        genImage(state, resolvedNewHref, text, link);
      } else if (isAudioRef) {
        genAudio(state, resolvedNewHref, text, link);
      } else if (isVideoRef) {
        genVideo(state, resolvedNewHref, text, link);
      } else {
        resolvedNewHref = resolvedNewHref + parsedHref.search + parsedHref.hash;
        genLink(state, resolvedNewHref, text, md, href, link);
      }
      return true;
    });
  };
};

exports.BiDirectionalLinks = BiDirectionalLinks;
